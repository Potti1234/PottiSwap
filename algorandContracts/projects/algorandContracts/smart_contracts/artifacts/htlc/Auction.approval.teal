#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0
    bytecblock "auctionInstancesAmount" 0x151f7c75 "auctionInstances" 0x0000000000000000
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/htlc/auction.algo.ts:34
    // public auctionInstancesAmount = GlobalState<uint64>({ initialValue: 0 });
    bytec_0 // "auctionInstancesAmount"
    intc_1 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/htlc/auction.algo.ts:32
    // export class Auction extends Contract {
    txn NumAppArgs
    bz main_bare_routing@11
    pushbytess 0x895650a3 0x19503819 0xeddfe598 0x64ccd930 // method "createAuction(uint64,uint64,uint64,uint64,uint64)uint64", method "getCurrentPrice(uint64)uint64", method "bid(uint64)void", method "latestTimestamp()uint64"
    txna ApplicationArgs 0
    match main_createAuction_route@5 main_getCurrentPrice_route@6 main_bid_route@7 main_latestTimestamp_route@8

main_after_if_else@15:
    // smart_contracts/htlc/auction.algo.ts:32
    // export class Auction extends Contract {
    intc_1 // 0
    return

main_latestTimestamp_route@8:
    // smart_contracts/htlc/auction.algo.ts:107
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub latestTimestamp
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_bid_route@7:
    // smart_contracts/htlc/auction.algo.ts:85
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/htlc/auction.algo.ts:32
    // export class Auction extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/htlc/auction.algo.ts:85
    // @arc4.abimethod()
    callsub bid
    intc_0 // 1
    return

main_getCurrentPrice_route@6:
    // smart_contracts/htlc/auction.algo.ts:75
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/htlc/auction.algo.ts:32
    // export class Auction extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/htlc/auction.algo.ts:75
    // @arc4.abimethod({ readonly: true })
    callsub getCurrentPrice
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_createAuction_route@5:
    // smart_contracts/htlc/auction.algo.ts:47
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/htlc/auction.algo.ts:32
    // export class Auction extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    txna ApplicationArgs 4
    btoi
    txna ApplicationArgs 5
    btoi
    // smart_contracts/htlc/auction.algo.ts:47
    // @arc4.abimethod()
    callsub createAuction
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_bare_routing@11:
    // smart_contracts/htlc/auction.algo.ts:32
    // export class Auction extends Contract {
    txn OnCompletion
    bnz main_after_if_else@15
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// smart_contracts/htlc/auction.algo.ts::Auction.createAuction(startPrice: uint64, minPrice: uint64, duration: uint64, escrowId: uint64, escrowAppId: uint64) -> uint64:
createAuction:
    // smart_contracts/htlc/auction.algo.ts:47-48
    // @arc4.abimethod()
    // public createAuction(startPrice: uint64, minPrice: uint64, duration: uint64, escrowId: uint64, escrowAppId: uint64): uint64 {
    proto 5 1
    // smart_contracts/htlc/auction.algo.ts:49
    // assert(startPrice > 0, "Start price must be positive");
    frame_dig -5
    assert // Start price must be positive
    // smart_contracts/htlc/auction.algo.ts:50
    // assert(minPrice > 0, "Min price must be positive");
    frame_dig -4
    assert // Min price must be positive
    // smart_contracts/htlc/auction.algo.ts:51
    // assert(duration > 0, "Duration must be positive");
    frame_dig -3
    assert // Duration must be positive
    // smart_contracts/htlc/auction.algo.ts:52
    // assert(Txn.sender === Global.creatorAddress, "Only the Relayer can create an auction");
    txn Sender
    global CreatorAddress
    ==
    assert // Only the Relayer can create an auction
    // smart_contracts/htlc/auction.algo.ts:55
    // escrowId: new UintN64(escrowId),
    frame_dig -2
    itob
    // smart_contracts/htlc/auction.algo.ts:56
    // escrowAppId: new UintN64(escrowAppId),
    frame_dig -1
    itob
    // smart_contracts/htlc/auction.algo.ts:34
    // public auctionInstancesAmount = GlobalState<uint64>({ initialValue: 0 });
    intc_1 // 0
    bytec_0 // "auctionInstancesAmount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/htlc/auction.algo.ts:57
    // auctionId: new UintN64(this.auctionInstancesAmount.value),
    itob
    // smart_contracts/htlc/auction.algo.ts:58
    // startPrice: new UintN64(startPrice),
    frame_dig -5
    itob
    // smart_contracts/htlc/auction.algo.ts:59
    // minPrice: new UintN64(minPrice),
    frame_dig -4
    itob
    // smart_contracts/htlc/auction.algo.ts:60
    // duration: new UintN64(duration),
    frame_dig -3
    itob
    // smart_contracts/htlc/auction.algo.ts:61
    // creator: new Address(Txn.sender),
    txn Sender
    // smart_contracts/htlc/auction.algo.ts:62
    // taker: new Address(Txn.sender),
    dup
    // smart_contracts/htlc/auction.algo.ts:63
    // startTime: new UintN64(this.latestTimestamp()),
    callsub latestTimestamp
    itob
    // smart_contracts/htlc/auction.algo.ts:54-66
    // const newAuctionInstance = new AuctionInstance({
    //   escrowId: new UintN64(escrowId),
    //   escrowAppId: new UintN64(escrowAppId),
    //   auctionId: new UintN64(this.auctionInstancesAmount.value),
    //   startPrice: new UintN64(startPrice),
    //   minPrice: new UintN64(minPrice),
    //   duration: new UintN64(duration),
    //   creator: new Address(Txn.sender),
    //   taker: new Address(Txn.sender),
    //   startTime: new UintN64(this.latestTimestamp()),
    //   sold: new UintN64(0),
    //   soldPrice: new UintN64(0),
    // });
    uncover 8
    uncover 8
    concat
    uncover 7
    concat
    uncover 6
    concat
    uncover 5
    concat
    uncover 4
    concat
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    // smart_contracts/htlc/auction.algo.ts:64
    // sold: new UintN64(0),
    bytec_3 // 0x0000000000000000
    // smart_contracts/htlc/auction.algo.ts:54-66
    // const newAuctionInstance = new AuctionInstance({
    //   escrowId: new UintN64(escrowId),
    //   escrowAppId: new UintN64(escrowAppId),
    //   auctionId: new UintN64(this.auctionInstancesAmount.value),
    //   startPrice: new UintN64(startPrice),
    //   minPrice: new UintN64(minPrice),
    //   duration: new UintN64(duration),
    //   creator: new Address(Txn.sender),
    //   taker: new Address(Txn.sender),
    //   startTime: new UintN64(this.latestTimestamp()),
    //   sold: new UintN64(0),
    //   soldPrice: new UintN64(0),
    // });
    concat
    // smart_contracts/htlc/auction.algo.ts:65
    // soldPrice: new UintN64(0),
    bytec_3 // 0x0000000000000000
    // smart_contracts/htlc/auction.algo.ts:54-66
    // const newAuctionInstance = new AuctionInstance({
    //   escrowId: new UintN64(escrowId),
    //   escrowAppId: new UintN64(escrowAppId),
    //   auctionId: new UintN64(this.auctionInstancesAmount.value),
    //   startPrice: new UintN64(startPrice),
    //   minPrice: new UintN64(minPrice),
    //   duration: new UintN64(duration),
    //   creator: new Address(Txn.sender),
    //   taker: new Address(Txn.sender),
    //   startTime: new UintN64(this.latestTimestamp()),
    //   sold: new UintN64(0),
    //   soldPrice: new UintN64(0),
    // });
    concat
    // smart_contracts/htlc/auction.algo.ts:34
    // public auctionInstancesAmount = GlobalState<uint64>({ initialValue: 0 });
    intc_1 // 0
    bytec_0 // "auctionInstancesAmount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/htlc/auction.algo.ts:68
    // this.auctionInstances(this.auctionInstancesAmount.value).value = newAuctionInstance.copy();
    itob
    // smart_contracts/htlc/auction.algo.ts:33
    // public auctionInstances = BoxMap<uint64, AuctionInstance>({ keyPrefix: "auctionInstances" });
    bytec_2 // "auctionInstances"
    swap
    concat
    // smart_contracts/htlc/auction.algo.ts:68
    // this.auctionInstances(this.auctionInstancesAmount.value).value = newAuctionInstance.copy();
    swap
    box_put
    // smart_contracts/htlc/auction.algo.ts:34
    // public auctionInstancesAmount = GlobalState<uint64>({ initialValue: 0 });
    intc_1 // 0
    bytec_0 // "auctionInstancesAmount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/htlc/auction.algo.ts:70
    // this.auctionInstancesAmount.value++;
    intc_0 // 1
    +
    // smart_contracts/htlc/auction.algo.ts:34
    // public auctionInstancesAmount = GlobalState<uint64>({ initialValue: 0 });
    bytec_0 // "auctionInstancesAmount"
    // smart_contracts/htlc/auction.algo.ts:70
    // this.auctionInstancesAmount.value++;
    swap
    app_global_put
    // smart_contracts/htlc/auction.algo.ts:34
    // public auctionInstancesAmount = GlobalState<uint64>({ initialValue: 0 });
    intc_1 // 0
    bytec_0 // "auctionInstancesAmount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/htlc/auction.algo.ts:72
    // return this.auctionInstancesAmount.value - 1;
    intc_0 // 1
    -
    retsub


// smart_contracts/htlc/auction.algo.ts::Auction.getCurrentPrice(auctionId: uint64) -> uint64:
getCurrentPrice:
    // smart_contracts/htlc/auction.algo.ts:75-76
    // @arc4.abimethod({ readonly: true })
    // public getCurrentPrice(auctionId: uint64): uint64 {
    proto 1 1
    // smart_contracts/htlc/auction.algo.ts:77
    // const auctionInstance = this.auctionInstances(auctionId).value.copy();
    frame_dig -1
    itob
    // smart_contracts/htlc/auction.algo.ts:33
    // public auctionInstances = BoxMap<uint64, AuctionInstance>({ keyPrefix: "auctionInstances" });
    bytec_2 // "auctionInstances"
    swap
    concat
    // smart_contracts/htlc/auction.algo.ts:77
    // const auctionInstance = this.auctionInstances(auctionId).value.copy();
    box_get
    assert // Box must have value
    // smart_contracts/htlc/auction.algo.ts:78
    // const elapsedTime: uint64 = this.latestTimestamp() - auctionInstance.startTime.native;
    callsub latestTimestamp
    dig 1
    pushint 112 // 112
    extract_uint64
    -
    // smart_contracts/htlc/auction.algo.ts:80
    // auctionInstance.startPrice.native -
    dig 1
    pushint 24 // 24
    extract_uint64
    // smart_contracts/htlc/auction.algo.ts:81
    // (auctionInstance.startPrice.native - auctionInstance.minPrice.native) * (elapsedTime / auctionInstance.duration.native);
    dig 2
    pushint 32 // 32
    extract_uint64
    dig 1
    swap
    -
    uncover 3
    pushint 40 // 40
    extract_uint64
    uncover 3
    swap
    /
    *
    // smart_contracts/htlc/auction.algo.ts:80-81
    // auctionInstance.startPrice.native -
    // (auctionInstance.startPrice.native - auctionInstance.minPrice.native) * (elapsedTime / auctionInstance.duration.native);
    -
    // smart_contracts/htlc/auction.algo.ts:82
    // return price;
    retsub


// smart_contracts/htlc/auction.algo.ts::Auction.bid(auctionId: uint64) -> void:
bid:
    // smart_contracts/htlc/auction.algo.ts:85-92
    // @arc4.abimethod()
    // /**
    //  * Bid on an auction
    //  *
    //  * @param auctionId ID of the auction
    //  * Can only be called by the whitelisted resolvers. If you bid on an auction the taker of the escrow is changed to the bidder.
    //  */
    // public bid(auctionId: uint64): void {
    proto 1 0
    // smart_contracts/htlc/auction.algo.ts:93
    // const auctionInstance = this.auctionInstances(auctionId).value.copy();
    frame_dig -1
    itob
    // smart_contracts/htlc/auction.algo.ts:33
    // public auctionInstances = BoxMap<uint64, AuctionInstance>({ keyPrefix: "auctionInstances" });
    bytec_2 // "auctionInstances"
    swap
    concat
    // smart_contracts/htlc/auction.algo.ts:93
    // const auctionInstance = this.auctionInstances(auctionId).value.copy();
    dup
    box_get
    assert // Box must have value
    // smart_contracts/htlc/auction.algo.ts:94
    // const currentPrice = this.getCurrentPrice(auctionId);
    frame_dig -1
    callsub getCurrentPrice
    // smart_contracts/htlc/auction.algo.ts:96
    // auctionInstance.taker = new Address(Txn.sender);
    txn Sender
    uncover 2
    swap
    replace2 80
    // smart_contracts/htlc/auction.algo.ts:97
    // auctionInstance.sold = new UintN64(1);
    pushbytes 0x0000000000000001
    replace2 120
    // smart_contracts/htlc/auction.algo.ts:98
    // auctionInstance.soldPrice = new UintN64(currentPrice);
    swap
    itob
    replace2 128
    // smart_contracts/htlc/auction.algo.ts:99
    // this.auctionInstances(auctionId).value = auctionInstance.copy();
    box_put
    retsub


// smart_contracts/htlc/auction.algo.ts::Auction.latestTimestamp() -> uint64:
latestTimestamp:
    // smart_contracts/htlc/auction.algo.ts:109
    // return Global.latestTimestamp;
    global LatestTimestamp
    retsub
