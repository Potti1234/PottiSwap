#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 0 1
    bytecblock "startPrice" 0x151f7c75 "minPrice" "duration" "taker" "startTime"
    // smart_contracts/htlc/auction.algo.ts:17
    // export class Auction extends Contract {
    txn NumAppArgs
    bz main_bare_routing@9
    pushbytess 0x229dc55b 0xd1717fe5 0xe08ef21e 0x64ccd930 // method "createAuction(uint64,uint64,uint64)void", method "getCurrentPrice()uint64", method "bid()void", method "latestTimestamp()uint64"
    txna ApplicationArgs 0
    match main_createAuction_route@3 main_getCurrentPrice_route@4 main_bid_route@5 main_latestTimestamp_route@6

main_after_if_else@13:
    // smart_contracts/htlc/auction.algo.ts:17
    // export class Auction extends Contract {
    intc_0 // 0
    return

main_latestTimestamp_route@6:
    // smart_contracts/htlc/auction.algo.ts:65
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub latestTimestamp
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_bid_route@5:
    // smart_contracts/htlc/auction.algo.ts:55
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub bid
    intc_1 // 1
    return

main_getCurrentPrice_route@4:
    // smart_contracts/htlc/auction.algo.ts:48
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub getCurrentPrice
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_1 // 1
    return

main_createAuction_route@3:
    // smart_contracts/htlc/auction.algo.ts:33
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/htlc/auction.algo.ts:17
    // export class Auction extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    btoi
    txna ApplicationArgs 3
    btoi
    // smart_contracts/htlc/auction.algo.ts:33
    // @arc4.abimethod()
    callsub createAuction
    intc_1 // 1
    return

main_bare_routing@9:
    // smart_contracts/htlc/auction.algo.ts:17
    // export class Auction extends Contract {
    txn OnCompletion
    bnz main_after_if_else@13
    txn ApplicationID
    !
    assert // can only call when creating
    intc_1 // 1
    return


// smart_contracts/htlc/auction.algo.ts::Auction.createAuction(startPrice: uint64, minPrice: uint64, duration: uint64) -> void:
createAuction:
    // smart_contracts/htlc/auction.algo.ts:33-34
    // @arc4.abimethod()
    // public createAuction(startPrice: uint64, minPrice: uint64, duration: uint64): void {
    proto 3 0
    // smart_contracts/htlc/auction.algo.ts:35
    // assert(startPrice > 0, "Start price must be positive");
    frame_dig -3
    assert // Start price must be positive
    // smart_contracts/htlc/auction.algo.ts:36
    // assert(minPrice > 0, "Min price must be positive");
    frame_dig -2
    assert // Min price must be positive
    // smart_contracts/htlc/auction.algo.ts:37
    // assert(duration > 0, "Duration must be positive");
    frame_dig -1
    assert // Duration must be positive
    // smart_contracts/htlc/auction.algo.ts:39
    // this.auctionId.value = this.latestTimestamp();
    callsub latestTimestamp
    // smart_contracts/htlc/auction.algo.ts:18
    // public auctionId = GlobalState<uint64>();
    pushbytes "auctionId"
    // smart_contracts/htlc/auction.algo.ts:39
    // this.auctionId.value = this.latestTimestamp();
    swap
    app_global_put
    // smart_contracts/htlc/auction.algo.ts:19
    // public startPrice = GlobalState<uint64>();
    bytec_0 // "startPrice"
    // smart_contracts/htlc/auction.algo.ts:40
    // this.startPrice.value = startPrice;
    frame_dig -3
    app_global_put
    // smart_contracts/htlc/auction.algo.ts:20
    // public minPrice = GlobalState<uint64>();
    bytec_2 // "minPrice"
    // smart_contracts/htlc/auction.algo.ts:41
    // this.minPrice.value = minPrice;
    frame_dig -2
    app_global_put
    // smart_contracts/htlc/auction.algo.ts:21
    // public duration = GlobalState<uint64>();
    bytec_3 // "duration"
    // smart_contracts/htlc/auction.algo.ts:42
    // this.duration.value = duration;
    frame_dig -1
    app_global_put
    // smart_contracts/htlc/auction.algo.ts:22
    // public creator = GlobalState<Address>();
    pushbytes "creator"
    // smart_contracts/htlc/auction.algo.ts:43
    // this.creator.value = new Address(Txn.sender);
    txn Sender
    app_global_put
    // smart_contracts/htlc/auction.algo.ts:23
    // public taker = GlobalState<Address>();
    bytec 4 // "taker"
    // smart_contracts/htlc/auction.algo.ts:44
    // this.taker.value = new Address(Txn.sender);
    txn Sender
    app_global_put
    // smart_contracts/htlc/auction.algo.ts:45
    // this.startTime.value = this.latestTimestamp();
    callsub latestTimestamp
    // smart_contracts/htlc/auction.algo.ts:24
    // public startTime = GlobalState<uint64>();
    bytec 5 // "startTime"
    // smart_contracts/htlc/auction.algo.ts:45
    // this.startTime.value = this.latestTimestamp();
    swap
    app_global_put
    retsub


// smart_contracts/htlc/auction.algo.ts::Auction.getCurrentPrice() -> uint64:
getCurrentPrice:
    // smart_contracts/htlc/auction.algo.ts:50
    // const elapsedTime: uint64 = this.latestTimestamp() - this.startTime.value;
    callsub latestTimestamp
    // smart_contracts/htlc/auction.algo.ts:24
    // public startTime = GlobalState<uint64>();
    intc_0 // 0
    bytec 5 // "startTime"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/htlc/auction.algo.ts:50
    // const elapsedTime: uint64 = this.latestTimestamp() - this.startTime.value;
    -
    // smart_contracts/htlc/auction.algo.ts:19
    // public startPrice = GlobalState<uint64>();
    intc_0 // 0
    bytec_0 // "startPrice"
    app_global_get_ex
    assert // check GlobalState exists
    intc_0 // 0
    bytec_0 // "startPrice"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/htlc/auction.algo.ts:20
    // public minPrice = GlobalState<uint64>();
    intc_0 // 0
    bytec_2 // "minPrice"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/htlc/auction.algo.ts:51
    // const price: uint64 = this.startPrice.value - (this.startPrice.value - this.minPrice.value) * (elapsedTime / this.duration.value);
    -
    // smart_contracts/htlc/auction.algo.ts:21
    // public duration = GlobalState<uint64>();
    intc_0 // 0
    bytec_3 // "duration"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/htlc/auction.algo.ts:51
    // const price: uint64 = this.startPrice.value - (this.startPrice.value - this.minPrice.value) * (elapsedTime / this.duration.value);
    uncover 3
    swap
    /
    *
    -
    // smart_contracts/htlc/auction.algo.ts:52
    // return price;
    retsub


// smart_contracts/htlc/auction.algo.ts::Auction.bid() -> void:
bid:
    // smart_contracts/htlc/auction.algo.ts:23
    // public taker = GlobalState<Address>();
    bytec 4 // "taker"
    // smart_contracts/htlc/auction.algo.ts:57
    // this.taker.value = new Address(Txn.sender);
    txn Sender
    app_global_put
    retsub


// smart_contracts/htlc/auction.algo.ts::Auction.latestTimestamp() -> uint64:
latestTimestamp:
    // smart_contracts/htlc/auction.algo.ts:67
    // return Global.latestTimestamp;
    global LatestTimestamp
    retsub
