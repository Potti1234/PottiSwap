#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 121 8
    bytecblock "escrowInstances" 0x151f7c75 "escrowInstancesAmount"
    // smart_contracts/htlc/contract.algo.ts:14
    // export class Escrow extends Contract {
    txn NumAppArgs
    bz main_bare_routing@10
    pushbytess 0x35b09041 0xa7dba54a 0x772b39ba 0xdee13de1 0x64ccd930 // method "create(uint64,byte[32],address,address)uint64", method "withdraw(byte[32],uint64)void", method "cancel(uint64)void", method "makeHash(byte[32])byte[]", method "latestTimestamp()uint64"
    txna ApplicationArgs 0
    match main_create_route@3 main_withdraw_route@4 main_cancel_route@5 main_makeHash_route@6 main_latestTimestamp_route@7

main_after_if_else@14:
    // smart_contracts/htlc/contract.algo.ts:14
    // export class Escrow extends Contract {
    intc_1 // 0
    return

main_latestTimestamp_route@7:
    // smart_contracts/htlc/contract.algo.ts:107
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub latestTimestamp
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_makeHash_route@6:
    // smart_contracts/htlc/contract.algo.ts:98
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/htlc/contract.algo.ts:14
    // export class Escrow extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/htlc/contract.algo.ts:98
    // @arc4.abimethod({ readonly: true })
    callsub makeHash
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_cancel_route@5:
    // smart_contracts/htlc/contract.algo.ts:69
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/htlc/contract.algo.ts:14
    // export class Escrow extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/htlc/contract.algo.ts:69
    // @arc4.abimethod()
    callsub cancel
    intc_0 // 1
    return

main_withdraw_route@4:
    // smart_contracts/htlc/contract.algo.ts:53
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/htlc/contract.algo.ts:14
    // export class Escrow extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/htlc/contract.algo.ts:53
    // @arc4.abimethod()
    callsub withdraw
    intc_0 // 1
    return

main_create_route@3:
    // smart_contracts/htlc/contract.algo.ts:27
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/htlc/contract.algo.ts:14
    // export class Escrow extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txna ApplicationArgs 4
    // smart_contracts/htlc/contract.algo.ts:27
    // @arc4.abimethod()
    callsub create
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_bare_routing@10:
    // smart_contracts/htlc/contract.algo.ts:14
    // export class Escrow extends Contract {
    txn OnCompletion
    bnz main_after_if_else@14
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// smart_contracts/htlc/contract.algo.ts::Escrow.create(timelock: uint64, secretHash: bytes, taker: bytes, creator: bytes) -> uint64:
create:
    // smart_contracts/htlc/contract.algo.ts:27-28
    // @arc4.abimethod()
    // public create(timelock: uint64, secretHash: arc4.StaticBytes<32>, taker: Address, creator: Address): uint64 {
    proto 4 1
    // smart_contracts/htlc/contract.algo.ts:29
    // const txnDeposit = gtxn.PaymentTxn(0);
    intc_1 // 0
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/htlc/contract.algo.ts:32
    // createdTime: this.latestTimestamp(),
    callsub latestTimestamp
    // smart_contracts/htlc/contract.algo.ts:33
    // rescueTime: Global.latestTimestamp + timelock,
    global LatestTimestamp
    frame_dig -4
    +
    // smart_contracts/htlc/contract.algo.ts:29
    // const txnDeposit = gtxn.PaymentTxn(0);
    intc_1 // 0
    // smart_contracts/htlc/contract.algo.ts:34
    // amount: txnDeposit.amount,
    gtxns Amount
    // smart_contracts/htlc/contract.algo.ts:15
    // public escrowInstances = GlobalState<EscrowInstance[]>();
    intc_1 // 0
    bytec_0 // "escrowInstances"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/htlc/contract.algo.ts:41
    // this.escrowInstances.value = [...this.escrowInstances.value, newEscrowInstance];
    extract 2 0
    // smart_contracts/htlc/contract.algo.ts:31
    // const newEscrowInstance: EscrowInstance = {
    uncover 3
    itob
    uncover 3
    itob
    concat
    uncover 2
    itob
    concat
    frame_dig -1
    concat
    frame_dig -2
    concat
    frame_dig -3
    concat
    pushbytes 0x80
    concat
    // smart_contracts/htlc/contract.algo.ts:41
    // this.escrowInstances.value = [...this.escrowInstances.value, newEscrowInstance];
    dup
    len
    intc_2 // 121
    /
    itob
    extract 6 2
    swap
    concat
    extract 2 0
    concat
    dup
    len
    intc_2 // 121
    /
    itob
    extract 6 2
    swap
    concat
    // smart_contracts/htlc/contract.algo.ts:15
    // public escrowInstances = GlobalState<EscrowInstance[]>();
    bytec_0 // "escrowInstances"
    // smart_contracts/htlc/contract.algo.ts:41
    // this.escrowInstances.value = [...this.escrowInstances.value, newEscrowInstance];
    swap
    app_global_put
    // smart_contracts/htlc/contract.algo.ts:16
    // public escrowInstancesAmount = GlobalState<uint64>();
    intc_1 // 0
    bytec_2 // "escrowInstancesAmount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/htlc/contract.algo.ts:43
    // this.escrowInstancesAmount.value++;
    intc_0 // 1
    +
    // smart_contracts/htlc/contract.algo.ts:16
    // public escrowInstancesAmount = GlobalState<uint64>();
    bytec_2 // "escrowInstancesAmount"
    // smart_contracts/htlc/contract.algo.ts:43
    // this.escrowInstancesAmount.value++;
    swap
    app_global_put
    // smart_contracts/htlc/contract.algo.ts:16
    // public escrowInstancesAmount = GlobalState<uint64>();
    intc_1 // 0
    bytec_2 // "escrowInstancesAmount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/htlc/contract.algo.ts:45
    // return this.escrowInstancesAmount.value;
    retsub


// smart_contracts/htlc/contract.algo.ts::Escrow.withdraw(secret: bytes, escrowId: uint64) -> void:
withdraw:
    // smart_contracts/htlc/contract.algo.ts:53-54
    // @arc4.abimethod()
    // public withdraw(secret: arc4.StaticBytes<32>, escrowId: uint64) {
    proto 2 0
    // smart_contracts/htlc/contract.algo.ts:15
    // public escrowInstances = GlobalState<EscrowInstance[]>();
    intc_1 // 0
    bytec_0 // "escrowInstances"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/htlc/contract.algo.ts:55
    // const escrowInstance = this.escrowInstances.value[escrowId];
    extract 2 0
    frame_dig -1
    intc_2 // 121
    *
    intc_2 // 121
    extract3 // on error: Index access is out of bounds
    dup
    intc_3 // 8
    extract_uint64
    dig 1
    pushint 16 // 16
    extract_uint64
    dig 2
    extract 56 32 // on error: Index access is out of bounds
    uncover 3
    extract 88 32 // on error: Index access is out of bounds
    // smart_contracts/htlc/contract.algo.ts:57
    // assert(this.makeHash(secret) === escrowInstance.secretHash.bytes, "The password is not correct");
    frame_dig -2
    callsub makeHash
    ==
    assert // The password is not correct
    // smart_contracts/htlc/contract.algo.ts:59
    // assert(this.latestTimestamp() < escrowInstance.rescueTime, "Escrow can be redeemed with password up to the rescue time");
    callsub latestTimestamp
    uncover 3
    <
    assert // Escrow can be redeemed with password up to the rescue time
    // smart_contracts/htlc/contract.algo.ts:62
    // this._send(escrowInstance.taker, escrowInstance.amount);
    swap
    callsub _send
    retsub


// smart_contracts/htlc/contract.algo.ts::Escrow.cancel(escrowId: uint64) -> void:
cancel:
    // smart_contracts/htlc/contract.algo.ts:69-70
    // @arc4.abimethod()
    // public cancel(escrowId: uint64) {
    proto 1 0
    // smart_contracts/htlc/contract.algo.ts:15
    // public escrowInstances = GlobalState<EscrowInstance[]>();
    intc_1 // 0
    bytec_0 // "escrowInstances"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/htlc/contract.algo.ts:71
    // const escrowInstance = this.escrowInstances.value[escrowId];
    extract 2 0
    frame_dig -1
    intc_2 // 121
    *
    intc_2 // 121
    extract3 // on error: Index access is out of bounds
    dup
    intc_3 // 8
    extract_uint64
    dig 1
    pushint 16 // 16
    extract_uint64
    uncover 2
    extract 24 32 // on error: Index access is out of bounds
    // smart_contracts/htlc/contract.algo.ts:73
    // assert(this.latestTimestamp() > escrowInstance.rescueTime, "The escrow cannot be canceled yet");
    callsub latestTimestamp
    uncover 3
    >
    assert // The escrow cannot be canceled yet
    // smart_contracts/htlc/contract.algo.ts:76
    // this._send(escrowInstance.creator, escrowInstance.amount);
    swap
    callsub _send
    retsub


// smart_contracts/htlc/contract.algo.ts::Escrow._send(receiver: bytes, amount: uint64) -> void:
_send:
    // smart_contracts/htlc/contract.algo.ts:82
    // private _send(receiver: Address, amount: uint64): void {
    proto 2 0
    // smart_contracts/htlc/contract.algo.ts:83-89
    // itxn
    //   .payment({
    //     amount: amount,
    //     fee: Global.minTxnFee,
    //     receiver: receiver.bytes,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/htlc/contract.algo.ts:86
    // fee: Global.minTxnFee,
    global MinTxnFee
    frame_dig -2
    itxn_field Receiver
    frame_dig -1
    itxn_field Amount
    // smart_contracts/htlc/contract.algo.ts:83-88
    // itxn
    //   .payment({
    //     amount: amount,
    //     fee: Global.minTxnFee,
    //     receiver: receiver.bytes,
    //   })
    intc_0 // 1
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/htlc/contract.algo.ts:83-89
    // itxn
    //   .payment({
    //     amount: amount,
    //     fee: Global.minTxnFee,
    //     receiver: receiver.bytes,
    //   })
    //   .submit();
    itxn_submit
    retsub


// smart_contracts/htlc/contract.algo.ts::Escrow.makeHash(secret: bytes) -> bytes:
makeHash:
    // smart_contracts/htlc/contract.algo.ts:98-99
    // @arc4.abimethod({ readonly: true })
    // public makeHash(secret: arc4.StaticBytes<32>): bytes {
    proto 1 1
    // smart_contracts/htlc/contract.algo.ts:100
    // return op.keccak256(secret.bytes);
    frame_dig -1
    keccak256
    retsub


// smart_contracts/htlc/contract.algo.ts::Escrow.latestTimestamp() -> uint64:
latestTimestamp:
    // smart_contracts/htlc/contract.algo.ts:109
    // return Global.latestTimestamp;
    global LatestTimestamp
    retsub
