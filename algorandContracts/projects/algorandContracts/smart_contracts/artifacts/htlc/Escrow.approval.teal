#pragma version 10
#pragma typetrack false

// @algorandfoundation/algorand-typescript/arc4/index.d.ts::Contract.approvalProgram() -> uint64:
main:
    intcblock 1 0 120 8
    bytecblock "escrowInstancesAmount" 0x151f7c75 "escrowInstances" 0x0000000000000000
    txn ApplicationID
    bnz main_after_if_else@2
    // smart_contracts/htlc/contract.algo.ts:29
    // public escrowInstancesAmount = GlobalState<uint64>({ initialValue: 0 });
    bytec_0 // "escrowInstancesAmount"
    intc_1 // 0
    app_global_put

main_after_if_else@2:
    // smart_contracts/htlc/contract.algo.ts:27
    // export class Escrow extends Contract {
    txn NumAppArgs
    bz main_bare_routing@12
    pushbytess 0xdeb6f0e6 0xa7dba54a 0x772b39ba 0xdee13de1 0x64ccd930 // method "create(uint64,byte[32],address,pay)uint64", method "withdraw(byte[32],uint64)void", method "cancel(uint64)void", method "makeHash(byte[32])byte[]", method "latestTimestamp()uint64"
    txna ApplicationArgs 0
    match main_create_route@5 main_withdraw_route@6 main_cancel_route@7 main_makeHash_route@8 main_latestTimestamp_route@9

main_after_if_else@16:
    // smart_contracts/htlc/contract.algo.ts:27
    // export class Escrow extends Contract {
    intc_1 // 0
    return

main_latestTimestamp_route@9:
    // smart_contracts/htlc/contract.algo.ts:127
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    callsub latestTimestamp
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_makeHash_route@8:
    // smart_contracts/htlc/contract.algo.ts:118
    // @arc4.abimethod({ readonly: true })
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/htlc/contract.algo.ts:27
    // export class Escrow extends Contract {
    txna ApplicationArgs 1
    // smart_contracts/htlc/contract.algo.ts:118
    // @arc4.abimethod({ readonly: true })
    callsub makeHash
    dup
    len
    itob
    extract 6 2
    swap
    concat
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_cancel_route@7:
    // smart_contracts/htlc/contract.algo.ts:84
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/htlc/contract.algo.ts:27
    // export class Escrow extends Contract {
    txna ApplicationArgs 1
    btoi
    // smart_contracts/htlc/contract.algo.ts:84
    // @arc4.abimethod()
    callsub cancel
    intc_0 // 1
    return

main_withdraw_route@6:
    // smart_contracts/htlc/contract.algo.ts:63
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/htlc/contract.algo.ts:27
    // export class Escrow extends Contract {
    txna ApplicationArgs 1
    txna ApplicationArgs 2
    btoi
    // smart_contracts/htlc/contract.algo.ts:63
    // @arc4.abimethod()
    callsub withdraw
    intc_0 // 1
    return

main_create_route@5:
    // smart_contracts/htlc/contract.algo.ts:39
    // @arc4.abimethod()
    txn OnCompletion
    !
    assert // OnCompletion is not NoOp
    txn ApplicationID
    assert // can only call when not creating
    // smart_contracts/htlc/contract.algo.ts:27
    // export class Escrow extends Contract {
    txna ApplicationArgs 1
    btoi
    txna ApplicationArgs 2
    txna ApplicationArgs 3
    txn GroupIndex
    intc_0 // 1
    -
    dup
    gtxns TypeEnum
    intc_0 // pay
    ==
    assert // transaction type is pay
    // smart_contracts/htlc/contract.algo.ts:39
    // @arc4.abimethod()
    callsub create
    itob
    bytec_1 // 0x151f7c75
    swap
    concat
    log
    intc_0 // 1
    return

main_bare_routing@12:
    // smart_contracts/htlc/contract.algo.ts:27
    // export class Escrow extends Contract {
    txn OnCompletion
    bnz main_after_if_else@16
    txn ApplicationID
    !
    assert // can only call when creating
    intc_0 // 1
    return


// smart_contracts/htlc/contract.algo.ts::Escrow.create(timelock: uint64, secretHash: bytes, taker: bytes, txnDeposit: uint64) -> uint64:
create:
    // smart_contracts/htlc/contract.algo.ts:39-40
    // @arc4.abimethod()
    // public create(timelock: uint64, secretHash: arc4.StaticBytes<32>, taker: Address, txnDeposit: gtxn.PaymentTxn): uint64 {
    proto 4 1
    // smart_contracts/htlc/contract.algo.ts:42
    // createdTime: new UintN64(this.latestTimestamp()),
    callsub latestTimestamp
    itob
    // smart_contracts/htlc/contract.algo.ts:43
    // rescueTime: new UintN64(Global.latestTimestamp + timelock),
    global LatestTimestamp
    frame_dig -4
    +
    itob
    // smart_contracts/htlc/contract.algo.ts:44
    // amount: new UintN64(txnDeposit.amount),
    frame_dig -1
    gtxns Amount
    itob
    // smart_contracts/htlc/contract.algo.ts:45
    // creator: new Address(txnDeposit.sender),
    frame_dig -1
    gtxns Sender
    // smart_contracts/htlc/contract.algo.ts:41-49
    // const newEscrowInstance = new EscrowInstance({
    //   createdTime: new UintN64(this.latestTimestamp()),
    //   rescueTime: new UintN64(Global.latestTimestamp + timelock),
    //   amount: new UintN64(txnDeposit.amount),
    //   creator: new Address(txnDeposit.sender),
    //   taker: taker,
    //   secretHash: secretHash,
    //   active: new UintN64(1),
    // });
    uncover 3
    uncover 3
    concat
    uncover 2
    concat
    swap
    concat
    frame_dig -2
    concat
    frame_dig -3
    concat
    // smart_contracts/htlc/contract.algo.ts:48
    // active: new UintN64(1),
    pushbytes 0x0000000000000001
    // smart_contracts/htlc/contract.algo.ts:41-49
    // const newEscrowInstance = new EscrowInstance({
    //   createdTime: new UintN64(this.latestTimestamp()),
    //   rescueTime: new UintN64(Global.latestTimestamp + timelock),
    //   amount: new UintN64(txnDeposit.amount),
    //   creator: new Address(txnDeposit.sender),
    //   taker: taker,
    //   secretHash: secretHash,
    //   active: new UintN64(1),
    // });
    concat
    // smart_contracts/htlc/contract.algo.ts:29
    // public escrowInstancesAmount = GlobalState<uint64>({ initialValue: 0 });
    intc_1 // 0
    bytec_0 // "escrowInstancesAmount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/htlc/contract.algo.ts:51
    // this.escrowInstances(this.escrowInstancesAmount.value).value = newEscrowInstance.copy();
    itob
    // smart_contracts/htlc/contract.algo.ts:28
    // public escrowInstances = BoxMap<uint64, EscrowInstance>({ keyPrefix: "escrowInstances" });
    bytec_2 // "escrowInstances"
    swap
    concat
    // smart_contracts/htlc/contract.algo.ts:51
    // this.escrowInstances(this.escrowInstancesAmount.value).value = newEscrowInstance.copy();
    swap
    box_put
    // smart_contracts/htlc/contract.algo.ts:29
    // public escrowInstancesAmount = GlobalState<uint64>({ initialValue: 0 });
    intc_1 // 0
    bytec_0 // "escrowInstancesAmount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/htlc/contract.algo.ts:53
    // this.escrowInstancesAmount.value++;
    intc_0 // 1
    +
    // smart_contracts/htlc/contract.algo.ts:29
    // public escrowInstancesAmount = GlobalState<uint64>({ initialValue: 0 });
    bytec_0 // "escrowInstancesAmount"
    // smart_contracts/htlc/contract.algo.ts:53
    // this.escrowInstancesAmount.value++;
    swap
    app_global_put
    // smart_contracts/htlc/contract.algo.ts:29
    // public escrowInstancesAmount = GlobalState<uint64>({ initialValue: 0 });
    intc_1 // 0
    bytec_0 // "escrowInstancesAmount"
    app_global_get_ex
    assert // check GlobalState exists
    // smart_contracts/htlc/contract.algo.ts:55
    // return this.escrowInstancesAmount.value;
    retsub


// smart_contracts/htlc/contract.algo.ts::Escrow.withdraw(secret: bytes, escrowId: uint64) -> void:
withdraw:
    // smart_contracts/htlc/contract.algo.ts:63-64
    // @arc4.abimethod()
    // public withdraw(secret: arc4.StaticBytes<32>, escrowId: uint64) {
    proto 2 0
    // smart_contracts/htlc/contract.algo.ts:65
    // const escrowInstance = this.escrowInstances(escrowId).value.copy();
    frame_dig -1
    itob
    // smart_contracts/htlc/contract.algo.ts:28
    // public escrowInstances = BoxMap<uint64, EscrowInstance>({ keyPrefix: "escrowInstances" });
    bytec_2 // "escrowInstances"
    swap
    concat
    // smart_contracts/htlc/contract.algo.ts:65
    // const escrowInstance = this.escrowInstances(escrowId).value.copy();
    dup
    box_get
    assert // Box must have value
    // smart_contracts/htlc/contract.algo.ts:67
    // assert(escrowInstance.active.native === 1, "Escrow is not active");
    dup
    intc_2 // 120
    extract_uint64
    intc_0 // 1
    ==
    assert // Escrow is not active
    // smart_contracts/htlc/contract.algo.ts:69
    // assert(this.makeHash(secret) === escrowInstance.secretHash.bytes, "The password is not correct");
    frame_dig -2
    callsub makeHash
    dig 1
    extract 88 32 // on error: Index access is out of bounds
    ==
    assert // The password is not correct
    // smart_contracts/htlc/contract.algo.ts:71
    // assert(this.latestTimestamp() < escrowInstance.rescueTime.native, "Escrow can be redeemed with password up to the rescue time");
    callsub latestTimestamp
    dig 1
    intc_3 // 8
    extract_uint64
    <
    assert // Escrow can be redeemed with password up to the rescue time
    // smart_contracts/htlc/contract.algo.ts:73
    // escrowInstance.active = new UintN64(0);
    bytec_3 // 0x0000000000000000
    replace2 120
    // smart_contracts/htlc/contract.algo.ts:74
    // this.escrowInstances(escrowId).value = escrowInstance.copy();
    swap
    dig 1
    box_put
    // smart_contracts/htlc/contract.algo.ts:77
    // this._send(escrowInstance.taker, escrowInstance.amount.native);
    dup
    extract 56 32 // on error: Index access is out of bounds
    swap
    pushint 16 // 16
    extract_uint64
    callsub _send
    retsub


// smart_contracts/htlc/contract.algo.ts::Escrow.cancel(escrowId: uint64) -> void:
cancel:
    // smart_contracts/htlc/contract.algo.ts:84-85
    // @arc4.abimethod()
    // public cancel(escrowId: uint64) {
    proto 1 0
    // smart_contracts/htlc/contract.algo.ts:86
    // const escrowInstance = this.escrowInstances(escrowId).value.copy();
    frame_dig -1
    itob
    // smart_contracts/htlc/contract.algo.ts:28
    // public escrowInstances = BoxMap<uint64, EscrowInstance>({ keyPrefix: "escrowInstances" });
    bytec_2 // "escrowInstances"
    swap
    concat
    // smart_contracts/htlc/contract.algo.ts:86
    // const escrowInstance = this.escrowInstances(escrowId).value.copy();
    dup
    box_get
    assert // Box must have value
    // smart_contracts/htlc/contract.algo.ts:88
    // assert(escrowInstance.active.native === 1, "Escrow is not active");
    dup
    intc_2 // 120
    extract_uint64
    intc_0 // 1
    ==
    assert // Escrow is not active
    // smart_contracts/htlc/contract.algo.ts:90
    // assert(this.latestTimestamp() > escrowInstance.rescueTime.native, "The escrow cannot be canceled yet");
    callsub latestTimestamp
    dig 1
    intc_3 // 8
    extract_uint64
    >
    assert // The escrow cannot be canceled yet
    // smart_contracts/htlc/contract.algo.ts:92
    // escrowInstance.active = new UintN64(0);
    bytec_3 // 0x0000000000000000
    replace2 120
    // smart_contracts/htlc/contract.algo.ts:93
    // this.escrowInstances(escrowId).value = escrowInstance.copy();
    swap
    dig 1
    box_put
    // smart_contracts/htlc/contract.algo.ts:96
    // this._send(escrowInstance.creator, escrowInstance.amount.native);
    dup
    extract 24 32 // on error: Index access is out of bounds
    swap
    pushint 16 // 16
    extract_uint64
    callsub _send
    retsub


// smart_contracts/htlc/contract.algo.ts::Escrow._send(receiver: bytes, amount: uint64) -> void:
_send:
    // smart_contracts/htlc/contract.algo.ts:102
    // private _send(receiver: Address, amount: uint64): void {
    proto 2 0
    // smart_contracts/htlc/contract.algo.ts:103-109
    // itxn
    //   .payment({
    //     amount: amount,
    //     fee: Global.minTxnFee,
    //     receiver: receiver.bytes,
    //   })
    //   .submit();
    itxn_begin
    // smart_contracts/htlc/contract.algo.ts:106
    // fee: Global.minTxnFee,
    global MinTxnFee
    frame_dig -2
    itxn_field Receiver
    frame_dig -1
    itxn_field Amount
    // smart_contracts/htlc/contract.algo.ts:103-108
    // itxn
    //   .payment({
    //     amount: amount,
    //     fee: Global.minTxnFee,
    //     receiver: receiver.bytes,
    //   })
    intc_0 // 1
    itxn_field TypeEnum
    itxn_field Fee
    // smart_contracts/htlc/contract.algo.ts:103-109
    // itxn
    //   .payment({
    //     amount: amount,
    //     fee: Global.minTxnFee,
    //     receiver: receiver.bytes,
    //   })
    //   .submit();
    itxn_submit
    retsub


// smart_contracts/htlc/contract.algo.ts::Escrow.makeHash(secret: bytes) -> bytes:
makeHash:
    // smart_contracts/htlc/contract.algo.ts:118-119
    // @arc4.abimethod({ readonly: true })
    // public makeHash(secret: arc4.StaticBytes<32>): bytes {
    proto 1 1
    // smart_contracts/htlc/contract.algo.ts:120
    // return op.keccak256(secret.bytes);
    frame_dig -1
    keccak256
    retsub


// smart_contracts/htlc/contract.algo.ts::Escrow.latestTimestamp() -> uint64:
latestTimestamp:
    // smart_contracts/htlc/contract.algo.ts:129
    // return Global.latestTimestamp;
    global LatestTimestamp
    retsub
